/*
虚函数(virtual)可以是内联函数(inline)吗
  ● 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
  ● 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
  ● inline virtual唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如Base::who()，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。）
*/

/*
虚函数内联使用
*/

#include <iostream>
using namespace std;
class Base 
{
public:
	inline virtual void who() 
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
	
};

class Derived :public Base
{
public:
	inline void who() 
	{
		cout << "I am Derived\n";//不写inline时隐式内联
	}
};

/*int main() 
{
	//此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。
	Base b;
	b.who();

	//此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。
	Base* ptr = new Derived();
	ptr->who();

	//因为Base有虚析构函数（Virtual ~Base(){}），所以delete时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄露。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
}*/