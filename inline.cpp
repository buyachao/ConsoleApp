/*
inline 内联函数
特征
  ● 相当于把内联函数里面的内容写在调用内联函数处；
  ● 相当于不用执行进入内联函数的步骤，直接执行函数体；
  ● 相当于宏，却比宏多了类型检查，真正具有函数特性；
  ● 不能包含循环、递归、switch等复杂操作；
  ● 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内敛函数。
*/

/*
inline函数使用
*/
//声明1（加inline，建议使用）
inline int functionName(int first, int second, ...);

//声明2（不加inline）
int functionName(int first, int second, ...);

//定义
inline int functionName(int first, int second, ...) {/**/};

//类内定义，隐式内联
class A 
{
	int doA() { return 0; } //隐式内联
};

//类外定义，需要显示内联
class B 
{
	int doA();
};
inline int B::doA() { return 0; } //需要显示内联

/*
编译器对inline函数的处理步骤
  1、将inline函数体复制到inline函数调用点处；
  2、为所用inline函数中的局部变量分配内存空间；
  3、将inline函数中的输入参数和返回值映射到调用方法的局部变量空间中；
  4、如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使用GOTO）。
*/

/*
优点
  1、内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高了程序的运行速度。
  2、内联函数相比宏函数来说，在代码展开时，会做安全检查和自动类型转换（同普通函数），而宏定义则不会。
  3、在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量。
  4、内联函数在运行时可调试，而宏定义不可以。
*/

/*
缺点
  1、代码膨胀，内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少；
     另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
  2、inline函数无法随着函数库升级而升级，inline函数的改变需要重新编译，不像non-inline可以直接链接。
  3、是否内联，程序员不可控，内联函数只是对编译器的建议，是否对函数内联，决定权在于编译其。
*/

